<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Data Structures Topics - Prereq Description (D3 Integration)</title>
    <link rel="stylesheet" href="expand.css" />
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <body>
    <h1>
      <div class="button-container">
        <a href="home.html"
          ><button class="button">
            <span>Back </span>
          </button></a
        >
        <span>Introduction to DS</span>
      </div>
    </h1>

    <nav id="topics-nav">
      <ul></ul>
    </nav>

    <div id="main-content-area">
      <div id="diagram-placeholder">
        <p>
          Select a main topic from the list above to see its prerequisites
          diagram.
        </p>
      </div>

      <div id="prereq-description-display" style="display: none">
        <h4>Prerequisite Description:</h4>
        <p id="current-prereq-description">
          Click on a prerequisite box in the diagram to see its description
          here.
        </p>
      </div>
    </div>

    <script>
      // 1. DATA STRUCTURE (Topics, Descriptions, and Prerequisites with their own descriptions)
      const dsModules = [
        {
          id: "ds-intro",
          title: "01. Introduction to Data Structures",
          longDescription:
            "This module covers the fundamentals: what a data structure is, why we need them, and how to analyze their efficiency using Big O notation. It also reviews basic concepts like memory allocation and simple data types.",
          prerequisites: [
            {
              id: "prereq-basic-prog",
              title: "Basic Programming",
              description:
                "Understanding of fundamental programming concepts in languages like C, C++, or Java (variables, operators, control flow).",
              order: 1,
            },
            {
              id: "prereq-data-types",
              title: "Data Types & Variables",
              description:
                "Knowledge of basic data types (int, float, char, boolean) and how to declare and use variables.",
              order: 2,
            },
            {
              id: "prereq-arrays",
              title: "Arrays",
              description:
                "Familiarity with arrays: declaration, initialization, accessing elements, and basic operations.",
              order: 3,
            },
            {
              id: "prereq-loops-funcs",
              title: "Loops & Functions",
              description:
                "Proficiency in using loops (for, while) and defining/calling functions to structure code.",
              order: 4,
            },
          ],
        },
        {
          id: "ds-stacks-queues",
          title: "02. Stacks and Queues",
          longDescription:
            "Learn about two fundamental linear data structures: Stacks (LIFO) and Queues (FIFO). This topic explores their operations (Push/Pop, Enqueue/Dequeue), typical use cases like function calls, and array-based or linked list implementations.",
          prerequisites: [
            {
              id: "prereq-arrays",
              title: "Arrays",
              description:
                "Familiarity with arrays: declaration, initialization, accessing elements, and basic operations.",
              order: 1,
            },
            {
              id: "prereq-funcs-modular",
              title: "Functions & Modular Code",
              description:
                "Ability to write reusable functions and organize code into logical modules.",
              order: 2,
            },
            {
              id: "prereq-expr-eval",
              title: "Expression Evaluation",
              description:
                "Basic understanding of how expressions are evaluated, useful for infix/postfix conversions.",
              order: 3,
            },
            {
              id: "prereq-adt",
              title: "Basic ADT",
              description:
                "An introductory understanding of Abstract Data Types (ADT) concept.",
              order: 4,
            },
          ],
        },
        {
          id: "ds-linked-lists",
          title: "03. Linked Lists",
          longDescription:
            "This chapter introduces dynamic data structures where elements are linked using pointers. You will study single, double, and circular linked lists, focusing on operations like insertion, deletion, and traversal, and dynamic memory management.",
          prerequisites: [
            {
              id: "prereq-pointers",
              title: "Pointers",
              description:
                "Core understanding of pointers, memory addresses, and pointer arithmetic.",
              order: 1,
            },
            {
              id: "prereq-dynamic-mem",
              title: "Dynamic Memory",
              description:
                "Knowledge of dynamic memory allocation and deallocation (malloc/free in C/C++, new/delete in C++).",
              order: 2,
            },
            {
              id: "prereq-structs",
              title: "Structures/Classes",
              description:
                "Familiarity with defining and using structures or classes to group related data.",
              order: 3,
            },
            {
              id: "prereq-array-vs-ptr",
              title: "Array vs Pointer Concepts",
              description:
                "Understanding the differences and relationships between arrays and pointers.",
              order: 4,
            },
          ],
        },
        {
          id: "ds-trees",
          title: "04. Trees",
          longDescription:
            "Explore non-linear structures starting with binary trees and binary search trees (BSTs). Key concepts include various traversal methods (Inorder, Preorder, Postorder) and balancing techniques for efficient search and retrieval operations.",
          prerequisites: [
            {
              id: "prereq-linked-list-concepts",
              title: "Linked List Concepts",
              description:
                "Solid understanding of linked list operations and node manipulation.",
              order: 1,
            },
            {
              id: "prereq-recursion",
              title: "Recursion",
              description:
                "Ability to write and understand recursive functions.",
              order: 2,
            },
            {
              id: "prereq-stack-logic",
              title: "Stack (for Traversal)",
              description:
                "Knowledge of stacks for iterative tree traversal algorithms.",
              order: 3,
            },
            {
              id: "prereq-binary-search-basics",
              title: "Binary Search Basics",
              description:
                "Understanding the principles of binary search on sorted data.",
              order: 4,
            },
          ],
        },
        {
          id: "ds-graphs",
          title: "05. Graphs",
          longDescription:
            "Graphs are flexible structures used to model networks and relationships. This module covers graph representations (adjacency matrix/list) and critical algorithms like Breadth-First Search (BFS), Depth-First Search (DFS), and finding shortest paths.",
          prerequisites: [
            {
              id: "prereq-tree-traversal",
              title: "Tree Traversal (DFS/BFS)",
              description:
                "Familiarity with depth-first and breadth-first search algorithms on trees.",
              order: 1,
            },
            {
              id: "prereq-stack-queue",
              title: "Stack & Queue",
              description:
                "Proficiency in using both stack and queue data structures.",
              order: 2,
            },
            {
              id: "prereq-2d-arrays",
              title: "2D Arrays (Adj. Matrix)",
              description:
                "Understanding of 2-dimensional arrays for representing matrices, e.g., adjacency matrices.",
              order: 3,
            },
            {
              id: "prereq-recursion",
              title: "Recursion",
              description:
                "Ability to write and understand recursive functions for graph algorithms.",
              order: 4,
            },
          ],
        },
        {
          id: "ds-searching-techniques",
          title: "06. Searching Techniques",
          longDescription:
            "Focuses on methods for quickly locating an item within a data structure. Topics include the efficiency of Linear Search versus Binary Search, as well as an introduction to Hashing for near-constant time lookups.",
          prerequisites: [
            {
              id: "prereq-arrays",
              title: "Arrays",
              description:
                "Strong understanding of array manipulation and indexing.",
              order: 1,
            },
            {
              id: "prereq-linear-binary-search",
              title: "Linear & Binary Search",
              description:
                "Knowledge of linear and binary search algorithms and their complexities.",
              order: 2,
            },
            {
              id: "prereq-modulo-op",
              title: "Modulo Operation (Hashing)",
              description:
                "Understanding of the modulo operator and its application in hashing.",
              order: 3,
            },
            {
              id: "prereq-funcs-logic",
              title: "Functions & Logic Building",
              description:
                "Ability to design and implement functions and develop logical problem-solving skills.",
              order: 4,
            },
          ],
        },
      ];

      let currentSelectedTopicId = null;

      // 2. FUNCTION TO RENDER THE MAIN TOPICS NAVIGATION
      function renderMainTopicsNav() {
        const navList = document.querySelector("#topics-nav ul");
        navList.innerHTML = "";

        dsModules.forEach((module) => {
          const li = document.createElement("li");
          const link = document.createElement("a");

          link.textContent = module.title;
          link.href = "#";
          link.dataset.moduleId = module.id;
          link.addEventListener("click", (e) => {
            e.preventDefault();
            displayTopicDiagram(module.id);
          });

          li.appendChild(link);
          navList.appendChild(li);
        });
      }

      // 3. FUNCTION TO DISPLAY THE DIAGRAM FOR A SELECTED MAIN TOPIC (NOW USING D3)
      function displayTopicDiagram(moduleId) {
        currentSelectedTopicId = moduleId;
        const topic = dsModules.find((m) => m.id === moduleId);
        const diagramPlaceholder = document.getElementById(
          "diagram-placeholder"
        );
        const prereqDescDisplay = document.getElementById(
          "prereq-description-display"
        );
        const currentPrereqDesc = document.getElementById(
          "current-prereq-description"
        );

        if (!topic) {
          diagramPlaceholder.innerHTML = "<p>Topic not found.</p>";
          prereqDescDisplay.style.display = "none";
          return;
        }

        // Clear the placeholder and show the description area
        diagramPlaceholder.innerHTML = "";
        prereqDescDisplay.style.display = "block";
        currentPrereqDesc.textContent =
          "Click on a node in the D3 diagram to see its prerequisite description here.";

        // --- Prepare data for D3 ---
        // Convert the topic and its prerequisites into a hierarchical structure
        const d3Data = {
          name: topic.title,
          description: topic.longDescription,
          children: topic.prerequisites.map((p) => ({
            name: p.title,
            description: p.description,
            id: p.id, // Keep ID for potential click events
          })),
        };

        // Render the D3 tree
        renderD3Tree(d3Data, diagramPlaceholder.id, topic.prerequisites);
      }

      // 4. D3 RENDERING FUNCTION (Adapted for 90-degree anti-clockwise rotation)
      function renderD3Tree(data, containerId, prerequisites) {
        const container = document.getElementById(containerId);
        const width = container.clientWidth;
        const height = container.clientHeight;
        const margin = { top: 0, right: 250, bottom: 30, left: 80 };

        // 1. Create the SVG container
        const svg = d3
          .select(`#${containerId}`)
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          // Center the view vertically
          .attr("viewBox", [-margin.left, -height / 2, width, height]);

        // 2. Compute the tree layout
        const treeLayout = d3
          .tree()
          // --- KEY CHANGE 1: Swap width and height for horizontal layout ---
          .size([
            height - margin.top - margin.bottom, // The height becomes the domain/spread (X-axis)
            width - margin.left - margin.right, // The width becomes the depth (Y-axis)
          ]);

        const root = d3.hierarchy(data);
        treeLayout(root);

        // --- KEY CHANGE 2: Adjust node positions for R-to-L flow ---
        // R-to-L means: root starts on the right (max X), children extend to the left (min X)
        // D3 tree layout calculates (x, y) for T-to-B.
        // We swap: new_x = d.y, new_y = d.x
        // We negate the new_x to make it flow from Right-to-Left: new_x = width - d.y - margin.right

        // Find max depth (needed for scaling the layout)
        const maxDepth = d3.max(root.descendants(), (d) => d.depth);
        const maxDepthY = d3.max(root.descendants(), (d) => d.y);

        // Calculate a scaling factor to fit the width properly
        const xDepthScale = (width - margin.left - margin.right) / maxDepthY;

        // 3. Draw the links (paths)
        // --- KEY CHANGE 3: Use linkHorizontal for X-Y swapped layout ---
        const linkGenerator = d3
          .linkHorizontal()
          // X is now the depth (d.y)
          // Y is now the domain spread (d.x)
          .x((d) => width - margin.right - d.y * xDepthScale) // Maps d.y (depth) to screen X, flowing R-to-L
          .y((d) => d.x - height / 2 + margin.top); // Maps d.x (spread) to screen Y, center-adjusted

        svg
          .append("g")
          .attr("fill", "none")
          .attr("stroke", "#555")
          .attr("stroke-opacity", 0.4)
          .attr("stroke-width", 1.5)
          .selectAll("path")
          .data(root.links())
          .join("path")
          .attr("d", linkGenerator);

        // 4. Draw the nodes
        const node = svg
          .append("g")
          .selectAll("g")
          .data(root.descendants())
          .join("g")
          // --- KEY CHANGE 4: Translate based on swapped and adjusted coordinates ---
          .attr(
            "transform",
            (d) =>
              `translate(${width - margin.right - d.y * xDepthScale},${
                d.x - height / 2 + margin.top
              })`
          )
          .attr(
            "class",
            (d) => `node ${d.children ? "node--internal" : "node--leaf"}`
          );

        // Add circles for visual nodes (No change here)
        node
          .append("circle")
          .attr("r", 5)
          .attr("fill", (d) =>
            d.depth === 0 ? "#90caf9" : d.children ? "#555" : "#90caf9"
          )
          .attr("stroke", (d) =>
            d.depth === 0 ? "#2196f3" : d.children ? "#555" : "#2196f3"
          )
          .attr("stroke-width", 2);

        // Add text labels
        node
          .append("text")
          .attr("dy", "0.31em")
          // --- KEY CHANGE 5: Adjust text position for R-to-L (Root text goes left, Leaf text goes right) ---
          .attr("x", (d) => (d.children ? 8 : -8)) // Root text is now on the left (x=8), Leaf text is on the right (x=-8)
          .attr("text-anchor", (d) => (d.children ? "start" : "end")) // Root text starts right of node, Leaf text ends left of node
          .text((d) => d.data.name)
          .clone(true)
          .lower()
          .attr("stroke-linejoin", "round")
          .attr("stroke-width", 3)
          .attr("stroke", "white");

        // Add click handler to leaf nodes (prerequisites) (No change here)
        node
          .filter((d) => !d.children && d.data.id)
          .attr("cursor", "pointer")
          .on("click", (event, d) => {
            handleD3PrereqClick(d.data.id, prerequisites);
          });
      }

      // 5. FUNCTION TO HANDLE CLICK ON A D3 PREREQUISITE NODE
      function handleD3PrereqClick(prereqId, currentPrerequisites) {
        const selectedPrereq = currentPrerequisites.find(
          (p) => p.id === prereqId
        );

        if (selectedPrereq) {
          const prereqDescDisplay = document.getElementById(
            "prereq-description-display"
          );
          const currentPrereqDesc = document.getElementById(
            "current-prereq-description"
          );

          prereqDescDisplay.style.display = "block"; // Ensure it's visible
          currentPrereqDesc.innerHTML = `<strong>${selectedPrereq.title}:</strong> ${selectedPrereq.description}`;
        }
      }

      // Initialize the page
      document.addEventListener("DOMContentLoaded", () => {
        renderMainTopicsNav();
        // Optionally display the first topic's diagram by default
        if (dsModules.length > 0) {
          displayTopicDiagram(dsModules[0].id);
        }
      });
    </script>
  </body>
</html>
